<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking Demo with Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
        }
        
        .container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        #webcam {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror the webcam feed */
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror the canvas to match webcam */
            pointer-events: none;
        }
        
        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror to match webcam */
            pointer-events: none;
            z-index: 5;
        }
        
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
        <div id="three-canvas"></div>
        <div id="status">Loading MediaPipe...</div>
    </div>

    <script src="./models/libs/hands.js"></script>
    <script src="./models/libs/drawing_utils.js"></script>
    <script src="./models/libs/camera_utils.js"></script>
    <script src="./models/libs/three.min.js"></script>
    <script type="module">
        import { initDebugPanel, updateDebugPanel } from './js/debugPanel.js';
        import { detectAllGestures } from './js/gestureDetector.js';

        document.addEventListener('DOMContentLoaded', () => {
            const videoElement = document.getElementById('webcam');
            const canvasElement = document.getElementById('canvas');
            const canvasCtx = canvasElement.getContext('2d');
            const statusElement = document.getElementById('status');
            const threeContainer = document.getElementById('three-canvas');
            
            // Three.js variables
            let scene, camera, renderer;

            // Hand tracking variables
            let rightHandActive = false;
            let leftHandActive = false;
            let lastColorChangeTime = 0;
            const colorChangeDelay = 500; // milliseconds

            // Right hand drag state
            let isTouching = false;      // 是否触摸球体
            let isSelected = false;      // 是否已选中(捏合中)
            let dragOffset = { x: 0, y: 0, z: 0 };  // 抓取点与球心的偏移
            let spherePosition = { x: 0, y: 0, z: 0 };  // 球体当前位置
            const handPinchThreshold = 0.08;  // 捏合判定阈值

            // Gesture detection state
            let previousHandsDistance = null;  // 用于检测双手缩放手势

            // Particle system variables
            let particleSystem;
            const particleCount = 2000;
            const particlePositions = new Float32Array(particleCount * 3);
            const particleColors = new Float32Array(particleCount * 3);
            const particleBasePositions = new Float32Array(particleCount * 3); // Store original positions
            const particleVelocities = new Float32Array(particleCount * 3);
            const particlePhases = new Float32Array(particleCount);

            // Ripple effect variables
            const ripples = [];
            const rippleDuration = 2000; // milliseconds

            // Spread control variables
            let targetSpread = 1.0;
            let currentSpread = 1.0;
            const spreadSmoothing = 0.1;

            // Base color for particles
            let baseColor = { r: 1.0, g: 0.0, b: 1.0 }; // Magenta as default

            // Keep canvas size in sync with window size
            function updateCanvasSize() {
                canvasElement.width = window.innerWidth;
                canvasElement.height = window.innerHeight;
            }
            
            // Initialize and properly set element sizes
            function initializeLayout() {
                updateCanvasSize();
            }
            
            // Update layout when window is resized
            window.addEventListener('resize', () => {
                initializeLayout();
                if (renderer) {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
                if (camera) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                }
            });
            
            // Set initial layout
            initializeLayout();
            
            // Initialize webcam
            async function initWebcam() {
                try {
                    // Try to get a high resolution stream
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            facingMode: 'user'
                        }
                    });
                    
                    videoElement.srcObject = stream;
                    
                    return new Promise((resolve) => {
                        videoElement.onloadedmetadata = () => {
                            // Ensure layout is updated when video loads
                            initializeLayout();
                            resolve(videoElement);
                        };
                    });
                } catch (error) {
                    statusElement.textContent = `Error accessing webcam: ${error.message}`;
                    console.error('Error accessing webcam:', error);
                    throw error;
                }
            }
            
            // Helper function to generate random neon colors
            function getRandomNeonColor() {
                const neonColors = [
                    0xFF00FF, // Magenta
                    0x00FFFF, // Cyan
                    0xFF3300, // Neon Orange
                    0x39FF14, // Neon Green
                    0xFF0099, // Neon Pink
                    0x00FF00, // Lime
                    0xFF6600, // Neon Orange-Red
                    0xFFFF00  // Yellow
                ];
                return neonColors[Math.floor(Math.random() * neonColors.length)];
            }
            
            // Initialize Three.js with particle system
            function initThreeJS() {
                // Create scene
                scene = new THREE.Scene();

                // Create camera
                camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                camera.position.z = 5;

                // Create renderer with transparent background
                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000, 0);
                threeContainer.appendChild(renderer.domElement);

                // Create particle geometry
                const particleGeometry = new THREE.BufferGeometry();

                // Generate particles on sphere surface
                const baseRadius = 2.0;

                for (let i = 0; i < particleCount; i++) {
                    // Use spherical coordinates for uniform distribution
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);

                    // Store base position
                    const x = baseRadius * Math.sin(phi) * Math.cos(theta);
                    const y = baseRadius * Math.sin(phi) * Math.sin(theta);
                    const z = baseRadius * Math.cos(phi);

                    particleBasePositions[i * 3] = x;
                    particleBasePositions[i * 3 + 1] = y;
                    particleBasePositions[i * 3 + 2] = z;

                    particlePositions[i * 3] = x;
                    particlePositions[i * 3 + 1] = y;
                    particlePositions[i * 3 + 2] = z;

                    // Initialize color (magenta)
                    particleColors[i * 3] = 1.0;
                    particleColors[i * 3 + 1] = 0.0;
                    particleColors[i * 3 + 2] = 1.0;

                    // Initialize velocity (random rotation direction)
                    particleVelocities[i * 3] = (Math.random() - 0.5) * 0.02;
                    particleVelocities[i * 3 + 1] = (Math.random() - 0.5) * 0.02;
                    particleVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.02;

                    // Random phase for pulsing effect
                    particlePhases[i] = Math.random() * Math.PI * 2;
                }

                particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

                // Create particle material with vertex colors
                const particleMaterial = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true
                });

                // Create particle system
                particleSystem = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particleSystem);

                // Add ambient light (for potential future enhancements)
                const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
                scene.add(ambientLight);

                // Start animation loop
                animate();
            }
            
            // Animation loop for Three.js with particle animation
            function animate() {
                requestAnimationFrame(animate);

                if (particleSystem) {
                    const time = Date.now() * 0.001;

                    // Pre-compute rotation values (same for all particles)
                    const rotationAngle = 0.01 + time * 0.1;
                    const cosAngle = Math.cos(rotationAngle);
                    const sinAngle = Math.sin(rotationAngle);

                    // Apply spread to base positions and animate particles
                    for (let i = 0; i < particleCount; i++) {
                        const i3 = i * 3;

                        // Get base position with spread (sphere center NOT included yet)
                        const baseX = particleBasePositions[i3] * currentSpread;
                        const baseY = particleBasePositions[i3 + 1] * currentSpread;
                        const baseZ = particleBasePositions[i3 + 2] * currentSpread;

                        // FIRST: Rotate around Y axis (around particle sphere's own center)
                        const rotatedX = baseX * cosAngle - baseZ * sinAngle;
                        const rotatedZ = baseX * sinAngle + baseZ * cosAngle;
                        const rotatedY = baseY;

                        // SECOND: Add pulsing effect
                        const pulse = 1 + 0.05 * Math.sin(time * 2 + particlePhases[i]);

                        // THIRD: Add sphere position translation (last step!)
                        particlePositions[i3] = rotatedX * pulse + spherePosition.x;
                        particlePositions[i3 + 1] = rotatedY * pulse + spherePosition.y;
                        particlePositions[i3 + 2] = rotatedZ * pulse + spherePosition.z;
                    }

                    // Update particle positions
                    particleSystem.geometry.attributes.position.needsUpdate = true;

                    // Update colors with ripple effect
                    updateColorsWithRipple(time);

                    // Update particle colors
                    particleSystem.geometry.attributes.color.needsUpdate = true;
                }

                // Render the scene
                renderer.render(scene, camera);
            }

            // Update particle colors with ripple effect
            function updateColorsWithRipple(time) {
                const currentTime = Date.now();

                // Update each particle's color
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    const particlePos = {
                        x: particlePositions[i3],
                        y: particlePositions[i3 + 1],
                        z: particlePositions[i3 + 2]
                    };

                    let finalColor = { ...baseColor };

                    // Calculate all active ripples' influence on this particle
                    for (let r = 0; r < ripples.length; r++) {
                        const ripple = ripples[r];
                        const age = currentTime - ripple.startTime;

                        if (age < rippleDuration) {
                            const distance = calculateDistance(particlePos, ripple.contactPoint);
                            const rippleRadius = age * 0.005; // Ripple expansion speed
                            const rippleWidth = 0.5;

                            // If particle is within the ripple wave front
                            if (Math.abs(distance - rippleRadius) < rippleWidth) {
                                const intensity = (1 - age / rippleDuration) * (1 - Math.abs(distance - rippleRadius) / rippleWidth);
                                finalColor = blendColors(finalColor, ripple.color, intensity * 0.8);
                            }
                        }
                    }

                    particleColors[i3] = finalColor.r;
                    particleColors[i3 + 1] = finalColor.g;
                    particleColors[i3 + 2] = finalColor.b;
                }

                // Clean up old ripples
                while (ripples.length > 0 && currentTime - ripples[0].startTime > rippleDuration) {
                    ripples.shift();
                }
            }

            // Helper function to blend two colors
            function blendColors(color1, color2, ratio) {
                return {
                    r: color1.r * (1 - ratio) + color2.r * ratio,
                    g: color1.g * (1 - ratio) + color2.g * ratio,
                    b: color1.b * (1 - ratio) + color2.b * ratio
                };
            }

            // Convert hex color to RGB object
            function hexToRgb(hex) {
                const r = ((hex >> 16) & 255) / 255;
                const g = ((hex >> 8) & 255) / 255;
                const b = (hex & 255) / 255;
                return { r, g, b };
            }
            
            // Calculate distance between two 3D points
            function calculateDistance(point1, point2) {
                const dx = point1.x - point2.x;
                const dy = point1.y - point2.y;
                const dz = point1.z - point2.z;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            }
            
            // Detect if a point is near any particle (for particle system)
            function isPointNearParticles(point) {
                // Convert normalized coordinates to world space
                const worldX = (point.x - 0.5) * 10;
                const worldY = (0.5 - point.y) * 10;
                const worldZ = 0;

                // Check distance to center with current spread
                const centerDistance = Math.sqrt(worldX * worldX + worldY * worldY + worldZ * worldZ);
                const threshold = 2.0 * currentSpread;

                return centerDistance < threshold;
            }

            // Check if a point is near the particle sphere (considering sphere position)
            function isPointNearParticlesWithPos(point, spherePos, spread) {
                const worldX = (point.x - 0.5) * 10;
                const worldY = (0.5 - point.y) * 10;
                const dx = worldX - spherePos.x;
                const dy = worldY - spherePos.y;
                const dz = -spherePos.z;
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                return distance < 2.0 * spread;
            }

            // Convert normalized coordinates to world coordinates
            function normalizedToWorld(point) {
                return {
                    x: (point.x - 0.5) * 10,
                    y: (0.5 - point.y) * 10,
                    z: 0
                };
            }

            // Get contact point on particle system
            function getContactPoint(point) {
                // Convert normalized coordinates to world space
                const worldX = (point.x - 0.5) * 10;
                const worldY = (0.5 - point.y) * 10;
                const worldZ = 0;

                // Normalize to get direction, scale to current spread
                const magnitude = Math.sqrt(worldX * worldX + worldY * worldY);
                if (magnitude > 0) {
                    const scale = 2.0 * currentSpread * 0.7;
                    return {
                        x: (worldX / magnitude) * scale,
                        y: (worldY / magnitude) * scale,
                        z: 0
                    };
                }

                return { x: 0, y: 0, z: 0 };
            }
            
            // Initialize MediaPipe Hands
            async function initMediaPipeHands() {
                statusElement.textContent = 'Initializing MediaPipe Hands...';

                const hands = new Hands({
                    locateFile: (file) => {
                        // Use local files for existing models, CDN for others
                        const localFiles = [
                            'hands_solution_packed_assets.data',
                            'hands_solution_packed_assets.fileset',
                            'hands_solution_packed_assets_loader.js',
                            'hands_solution_simd_wasm_bin.js',
                            'hands_solution_simd_wasm_bin.wasm',
                            'hands_solution_similarity_calculator.data',
                            'hands.binarypb',
                            'hand_landmark_full.tflite'
                        ];
                        if (localFiles.includes(file)) {
                            return `./models/hands/${file}`;
                        }
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
                
                hands.setOptions({
                    maxNumHands: 2,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                await hands.initialize();
                statusElement.textContent = 'Hand tracking ready!';
                
                return hands;
            }
            
            // Draw hand landmarks on canvas with dynamic sizing
            function drawLandmarks(landmarks, isLeft, isTouching = false, isSelected = false) {
                // Adjust line width and point size based on screen dimension
                const screenSize = Math.min(window.innerWidth, window.innerHeight);
                const lineWidth = Math.max(2, Math.min(5, screenSize / 300));
                const pointSize = Math.max(2, Math.min(8, screenSize / 250));

                // Define connections between landmarks
                const connections = [
                    // Thumb
                    [0, 1], [1, 2], [2, 3], [3, 4],
                    // Index finger
                    [0, 5], [5, 6], [6, 7], [7, 8],
                    // Middle finger
                    [0, 9], [9, 10], [10, 11], [11, 12],
                    // Ring finger
                    [0, 13], [13, 14], [14, 15], [15, 16],
                    // Pinky
                    [0, 17], [17, 18], [18, 19], [19, 20],
                    // Palm
                    [0, 5], [5, 9], [9, 13], [13, 17]
                ];

                // Choose color based on state for right hand
                let handColor;
                if (isSelected) {
                    handColor = '#FFFFFF';  // White when selected
                } else if (isTouching) {
                    handColor = '#FFFF00';  // Yellow when touching
                } else if (isLeft) {
                    handColor = '#00FF00';  // Green for left hand
                } else {
                    handColor = '#00FFFF';  // Cyan for right hand (default)
                }
                
                // Draw connections
                canvasCtx.lineWidth = lineWidth;
                canvasCtx.strokeStyle = handColor;
                
                connections.forEach(([i, j]) => {
                    const start = landmarks[i];
                    const end = landmarks[j];
                    
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(start.x * canvasElement.width, start.y * canvasElement.height);
                    canvasCtx.lineTo(end.x * canvasElement.width, end.y * canvasElement.height);
                    canvasCtx.stroke();
                });
                
                // Draw landmarks
                landmarks.forEach((landmark, index) => {
                    // Special color for thumb tip (index 4) and index finger tip (index 8)
                    let pointColor = handColor;
                    if (index === 4 || index === 8) {
                        pointColor = '#FF0000';
                    }
                    
                    canvasCtx.fillStyle = pointColor;
                    canvasCtx.beginPath();
                    canvasCtx.arc(
                        landmark.x * canvasElement.width,
                        landmark.y * canvasElement.height,
                        pointSize * 1.2,  // Make thumb and index fingertips slightly larger
                        0,
                        2 * Math.PI
                    );
                    canvasCtx.fill();
                });
            }
            
            // Process video frames
            function onResults(results) {
                // Clear canvas
                canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
                
                // Make sure canvas size matches window
                if (canvasElement.width !== window.innerWidth || 
                    canvasElement.height !== window.innerHeight) {
                    updateCanvasSize();
                }
                
                // Reset the tracking flags for this frame
                rightHandActive = false;
                leftHandActive = false;
                let pinchDistance = 0;  // Track pinch distance for debug panel
                
                // Process hand landmarks if detected
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    // Update status text
                    statusElement.textContent = 
                        results.multiHandLandmarks.length === 1 ? '1 hand detected' :
                        `${results.multiHandLandmarks.length} hands detected`;
                    
                    // Process each hand
                    for (let handIndex = 0; handIndex < results.multiHandLandmarks.length; handIndex++) {
                        const landmarks = results.multiHandLandmarks[handIndex];
                        const handedness = results.multiHandedness[handIndex].label;
                        const isLeftHand = handedness === 'Left';

                        if (!isLeftHand) {
                            // RIGHT HAND: Touch-pinch-drag interaction
                            const thumbTip = landmarks[4];
                            const indexTip = landmarks[8];

                            // 1. Check if BOTH thumb and index are touching the sphere
                            const thumbNear = isPointNearParticlesWithPos(thumbTip, spherePosition, currentSpread);
                            const indexNear = isPointNearParticlesWithPos(indexTip, spherePosition, currentSpread);
                            const bothTouching = thumbNear && indexNear;

                            // 2. Calculate pinch distance
                            pinchDistance = calculateDistance(thumbTip, indexTip);

                            // 3. State machine
                            // 一旦选中，需要松开捏合才能取消选中（而不是暂时偏离触摸区）
                            if (isSelected) {
                                if (pinchDistance < handPinchThreshold) {
                                    // Selected and still pinching → drag mode
                                    const handWorldPos = normalizedToWorld(indexTip);
                                    spherePosition.x = handWorldPos.x - dragOffset.x;
                                    spherePosition.y = handWorldPos.y - dragOffset.y;
                                    spherePosition.z = handWorldPos.z - dragOffset.z;

                                    // Apply screen boundary constraints
                                    const aspectRatio = window.innerWidth / window.innerHeight;
                                    const boundaryY = 4.5;
                                    const boundaryX = boundaryY * aspectRatio;

                                    spherePosition.x = Math.max(-boundaryX, Math.min(boundaryX, spherePosition.x));
                                    spherePosition.y = Math.max(-boundaryY, Math.min(boundaryY, spherePosition.y));
                                    spherePosition.z = Math.max(-2, Math.min(2, spherePosition.z));
                                } else {
                                    // 松开捏合 → 取消选中
                                    isSelected = false;
                                }
                            } else if (bothTouching && pinchDistance < handPinchThreshold) {
                                // Both touching + pinching → select the object
                                isSelected = true;
                                const handWorldPos = normalizedToWorld(indexTip);
                                dragOffset = {
                                    x: handWorldPos.x - spherePosition.x,
                                    y: handWorldPos.y - spherePosition.y,
                                    z: handWorldPos.z - spherePosition.z
                                };
                            }

                            // Touch state for visual feedback
                            isTouching = bothTouching;
                            rightHandActive = true;

                            // Draw the hand landmarks AFTER computing state
                            drawLandmarks(landmarks, isLeftHand, isTouching, isSelected);
                        } else {
                            // LEFT HAND: Only draw, no interaction
                            leftHandActive = true;
                            drawLandmarks(landmarks, isLeftHand, false, false);
                        }
                    }
                } else {
                    statusElement.textContent = 'No hands detected';
                }

                // Detect all gestures using the gesture detector module
                const allGestures = detectAllGestures(results, previousHandsDistance);

                // Update previous hands distance for zoom detection
                if (allGestures.twoHand && allGestures.twoHand.bothPresent) {
                    previousHandsDistance = allGestures.twoHand.distance;
                } else {
                    previousHandsDistance = null;
                }

                // Update debug panel with current state
                updateDebugPanel({
                    leftHand: leftHandActive,
                    rightHand: rightHandActive,
                    pinchDistance: pinchDistance,
                    isTouching: isTouching,
                    isSelected: isSelected,
                    spherePosition: { ...spherePosition },
                    spread: currentSpread,
                    baseColor: { ...baseColor },
                    ripplesCount: ripples.length,
                    gestures: allGestures  // 添加完整的手势状态
                });
            }
            
            // Initialize and start the app
            async function startApp() {
                try {
                    await initWebcam();
                    initThreeJS(); // Initialize Three.js
                    initDebugPanel(); // Initialize debug panel
                    const hands = await initMediaPipeHands();
                    
                    hands.onResults(onResults);
                    
                    const camera = new Camera(videoElement, {
                        onFrame: async () => {
                            await hands.send({image: videoElement});
                        },
                        width: 1920,
                        height: 1080
                    });
                    
                    camera.start();
                    
                } catch (error) {
                    statusElement.textContent = `Error: ${error.message}`;
                    console.error('Error starting application:', error);
                }
            }
            
            // Start the application
            startApp();
        });
    </script>
</body>
</html>